AttackBox的重构

粗看到一些困难
	API库的派生类MonoBehaviour
	使用GetComponent
	访问Transfrom
	Actor
	条件检查集合
	ActionState

想像的步骤
	在测试中创建ActionBox
	将功能都提成一般的成员函数
	准备好搬家
	新类AttackBoxLogic搬家
	在原AttackBox类上建立委托
	修复创建原AttackBox类的地方
	测试
	
真实的步骤
	B1 = 修改代码的艺术
	“护”是首要目的，有了“护”之后，重构就可以大胆了
	分析原AttackBox的职责
	
	新建测试的solution与project
	建立项目的引用关系
	添加AttackBoxTests测试类
	添加第一个测试函数testCreate
	让第一个测试函数编译通过
		发现AttackBox派生自MonoBehaviour，根本构造不出来
		分离AttackBox与MonoBehaviour的关系
			将AttackBox里面所有public的函数内容全部分离到一New****的函数里面去，参考B1.25.7
			New***的函数全是private的
			将所有的private成员变量与这些New***集中到一起
			建立一个新类AttackBoxImpl
			将所有集中在一起的New***与成员变量都剪切过去
			在AttackBox中新建AttackBoxImpl
			修复AttackBox中的函数连接关系-委托到AttackBoxImpl
			修复AttackBoxImpl中的编译错误
				调用非New开始原AttackBox中的函数，改成New开头的函数
				调用基类的函数与属性
					各种GetComponent，要让人疯了
					要引入AttackBox的GameObject进来
						这个问题让我头发都白了，试了几种方法
						对代码进行阅读，寻找灵感
						最终使用B1.25.1与B1.25.6来解决这个问题
						更换GetTransform().parent为NewGetParent()函数，为了安全，先手工替换，再改函数名
						ILikeGameObject
						LikeGameObjectImpl
						FakeLikeGameObject
						TestingAttackBoxImpl
						
						TestCreate成功
			
	第一个真正的功能测试
		找了一个简单的NewCheck来做测试
		寻找里面可以感知的地方
			Assert.AreEqual(null, f.NewGetAM());
			f.NewCheck();
			Assert.AreNotEqual(null, f.NewGetAM());
		编译 - 成功
		运行 - 失败
			错误原因：System.Security.SecurityException ECall
			到处找原因(ildasm.exe, google)，结果发现是因为代码里面使用了
				rActionInfo.GetShaftByGO
				这个类是直接从MonoBehaviour继承下来的
				当在代码里面直接使用从MonoBehaviour继承下来的类，会直接得到这个错误
				这意味着，之后的代码要把所有MonoBehaviour的东西全部消灭掉
				开始去消灭这个问题吧
				去掉MonoBehaviour的问题
		运行 - 失败
			错误原因：ActionManager,ActionInfo，都是空的
				无法创建这两个类，因为它们又是MonoBehaviour的
				为它们建立interface，在AttackBoxImpl中直接使用这些interface去操作
					改成interface之后，各种编译不过的问题，一个个的去修正
				为这些interface建立Fake对象，在测试中可以去用
		运行 - 成功
		添加f.NetGetAttack相关的测试
		运行 - 失败
			添加ShaftAttack到 TestingAttackBoxImpl内
			在测试函数里面手动设置上这个变量
		运行 - 成功
		
	添加测试TestOnTriggerEnter
		先写测试代码，对这个函数的一个预期，写上断言
		让编译通过
			为了编译通过，还是做了一点保守的重构
			接口上面也添加了几个接缝函数TypeName,NewActor
			原本还在那里想着ILikeGameObject需要做一个工厂，正式与测试使用不同的工厂
				结果重构完之后不需要了，因为ILikeGameObject的实体都是由外部传进来的，内部并没有去建立
					之前内部建立的那些，通过重载了==号之后，都消灭掉了，里面所有GO相关的代码都消失了
					不可思议
			之前搬家过来的一些public的函数，现在不需要public了，设置成private
		运行 - 失败
			继续处理内部逻辑中的问题
				ShaftAttack上面的AttackTargetType的值
				tag的值
				GetType.Name的值
		编译 - 成功
		运行 - 成功
	
	添加更多的测试，由于业务逻辑主要是在OnTriggerEnter里面，所以对它所了几种不同环境的测试，看结果是否与设想的一样
		先写测试代码
		编译通过
		运行通过
			非常快速就搞定了
			突然感觉心头空空的，石头没有了
	
	可以进行重构了
		清理函数名
		下次在处理类的时候，一定要注意找到类里面最重的职责，要去影响外面什么东西，这才是关键
			actionState.OnAttacked就是AttackBoxImpl里面最重的一个位置了
		！！！严重问题！！！重构的过程中发现，之前写的测试代码是有问题的，一些地方都没有检测到
		
	??????然后呢，重构？下一个测试？
	
			
	
-------------------------------------------------------------	
记录从【全局变量】到【抽象接口、实现】经历的过程
接口传达职责而非实现细节

解依赖，比喻为：
从现实中的类似情况中找，就是“提纯”的工作
把要解依赖的代码想像成一个融合了各种材质的方块体
现要从这个代码块分离出耦合的东西出来
	往上提
	向下拉
	独立出一块（派生替换函数）
	假物代替（接口）